import "hashes/poseidon/poseidon" as poseidon;

// TODO how to solve the problem of variable tree depth depending on the size of the dataset
const u32 TREE_DEPTH = 16;


def select(bool condition, field left, field right) -> (field, field) {
    return (condition ? right : left, condition ? left : right);
}

// Merkle-Tree inclusion proof for tree depth <DEPTH> using Poseidon
def merkleTreeProof<DEPTH>(
    field root, 
    field leaf, 
    bool[DEPTH] directionSelector, 
    field[DEPTH] path
) -> bool {
    // Start from the leaf
    field mut digest = leaf;

    // Loop up the tree
    for u32 i in 0..DEPTH {
        (field, field) s = select(directionSelector[i], digest, path[i]);
        digest = poseidon([s.0, s.1]);
    }

    return digest == root;
}

// Main function
def main(
    field treeRoot, 
    field leaf, 
    private bool[TREE_DEPTH] directionSelector, 
    private field[TREE_DEPTH] path
) {
    assert(merkleTreeProof(treeRoot, leaf, directionSelector, path));
}